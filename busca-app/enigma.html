<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enigma do Cérebro Digital</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #ffffff;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .brain-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            background: #ffffff;
            border: 4px solid #000000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .brain-image {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            object-fit: cover;
        }

        .circuit-path {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .circuit-line {
            fill: none;
            stroke: #000000;
            stroke-width: 2;
            stroke-dasharray: 0;
            opacity: 0.8;
        }

        .circuit-line.moving {
            animation: drawCircuit 4s linear infinite;
        }

        .circuit-line.fixed {
            animation: none;
            opacity: 1;
            stroke-width: 3;
        }

        .circuit-dot {
            fill: #000000;
            r: 4;
        }

        .circuit-dot.moving {
            animation: moveDot 4s linear infinite;
	    r: 6;
    	    fill: #000000;
        }

        .circuit-dot.fixed {
            fill: #ff6600;
            r: 8;
            cursor: pointer;
            animation: none;
        }

        .circuit-dot.fixed:hover {
            fill: #ff0066;
            r: 10;
        }

        .option-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            transform: translateX(-50%) translateY(-40px);
            transition: all 0.3s ease;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1000;
            left: 50%;
        }

        .option-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -8px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 8px 6px 0 6px;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
        }

        .circuit-dot.fixed:hover + .option-tooltip {
            opacity: 1;
            transform: translateX(-50%) translateY(-50px);
        }

        @keyframes drawCircuit {
            0% {
                stroke-dasharray: 0 1000;
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                stroke-dasharray: 1000 0;
                opacity: 0;
            }
        }

        @keyframes moveDot {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                opacity: 0;
            }
        }

        .glow-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 250px;
            height: 250px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.05) 0%, transparent 70%);
            border-radius: 50%;
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.3;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 0.1;
            }
        }

        .title {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #000000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 200;
        }

        .subtitle {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #000000;
            font-size: 14px;
            opacity: 0.7;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">ENIGMA NEURAL</div>
        <div class="subtitle">Passe o mouse sobre os pontos laranja para revelar as opções</div>
        
        <div class="glow-effect"></div>
        
        <div class="brain-center">
            <img src="C:\Users\cydyq\Documents\Imagens\circulocentral.jpg" alt="Símbolo Central" class="brain-image">
        </div>

        <svg id="circuits-container" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 5;">
            </svg>
    </div>

    <script>
        // These lines were misplaced and are now correctly inside the script tag.
        const svg = document.getElementById('circuits-container');
        const svgNS = "http://www.w3.org/2000/svg";

        // MODIFICAÇÃO 2: Posições ajustadas para sair da borda do círculo central
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const circleRadius = 75; // Raio do círculo central (150px/2)
        
        const fixedOptions = [
            { angle: 0, text: "ACESSO PRINCIPAL", startX: centerX + circleRadius, startY: centerY, endX: centerX + 250, endY: centerY },
            { angle: 90, text: "CONFIGURAÇÕES", startX: centerX, startY: centerY + circleRadius, endX: centerX, endY: centerY + 250 },
            { angle: 180, text: "DADOS SECRETOS", startX: centerX - circleRadius, startY: centerY, endX: centerX - 250, endY: centerY },
            { angle: 270, text: "MODO OCULTO", startX: centerX, startY: centerY - circleRadius, endX: centerX, endY: centerY - 250 }
        ];

        // Função para criar trajetória de circuito digital
        function createCircuitPath(startX, startY, endX, endY, complexity = 3) {
            const segments = [];
            let currentX = startX;
            let currentY = startY;
            
            // Distância total
            const totalDistX = endX - startX;
            const totalDistY = endY - startY;
            
            // Criar segmentos com mudanças de direção
            for (let i = 0; i < complexity; i++) {
                const progress = (i + 1) / complexity;
                const nextX = startX + (totalDistX * progress) + (Math.random() - 0.5) * 100;
                const nextY = startY + (totalDistY * progress) + (Math.random() - 0.5) * 100;
                
                // Primeiro segmento horizontal ou vertical
                if (Math.random() > 0.5) {
                    segments.push(`L ${nextX} ${currentY}`);
                    segments.push(`L ${nextX} ${nextY}`);
                } else {
                    segments.push(`L ${currentX} ${nextY}`);
                    segments.push(`L ${nextX} ${nextY}`);
                }
                
                currentX = nextX;
                currentY = nextY;
            }
            
            // Último segmento para o destino
            if (Math.random() > 0.5) {
                segments.push(`L ${endX} ${currentY}`);
                segments.push(`L ${endX} ${endY}`);
            } else {
                segments.push(`L ${currentX} ${endY}`);
                segments.push(`L ${endX} ${endY}`);
            }
            
            return `M ${startX} ${startY} ${segments.join(' ')}`;
        }

        // Criar circuitos fixos
        fixedOptions.forEach((option, index) => {
            const g = document.createElementNS(svgNS, 'g');
            
            const path = document.createElementNS(svgNS, 'path');
            const pathData = createCircuitPath(option.startX, option.startY, option.endX, option.endY, 2);
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'circuit-line fixed');
            
            const dot = document.createElementNS(svgNS, 'circle');
            dot.setAttribute('cx', option.endX);
            dot.setAttribute('cy', option.endY);
            dot.setAttribute('class', 'circuit-dot fixed');
            
            // Tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'option-tooltip';
            tooltip.textContent = option.text;
            tooltip.style.left = `${option.endX}px`;
            tooltip.style.top = `${option.endY}px`;
            
            g.appendChild(path);
            g.appendChild(dot);
            svg.appendChild(g);
            document.body.appendChild(tooltip);
            
            // Event listeners
            dot.addEventListener('mouseenter', () => {
                tooltip.style.opacity = '1';
                tooltip.style.transform = 'translateX(-50%) translateY(-50px)';
            });
            
            dot.addEventListener('mouseleave', () => {
                tooltip.style.opacity = '0';
                tooltip.style.transform = 'translateX(-50%) translateY(-40px)';
            });
            
            dot.addEventListener('click', () => {
                alert(`Opção selecionada: ${option.text}`);
            });
        });

        // Função para criar circuitos animados
        function createAnimatedCircuit() {
            const g = document.createElementNS(svgNS, 'g');
            
            // MODIFICAÇÃO 3: Ponto de partida na borda do círculo central
            const startAngle = Math.random() * 2 * Math.PI;
            const startX = centerX + Math.cos(startAngle) * circleRadius;
            const startY = centerY + Math.sin(startAngle) * circleRadius;
            
            // Ponto de destino aleatório fora da tela
            const endAngle = Math.random() * 2 * Math.PI;
            const distance = Math.max(window.innerWidth, window.innerHeight) * 0.8;
            const endX = centerX + Math.cos(endAngle) * distance;
            const endY = centerY + Math.sin(endAngle) * distance;
            
            const path = document.createElementNS(svgNS, 'path');
            const pathData = createCircuitPath(startX, startY, endX, endY, Math.floor(Math.random() * 4) + 2);
            path.setAttribute('d', pathData);
            path.setAttribute('class', 'circuit-line moving');
            path.style.animationDelay = `${Math.random() * 2}s`;
            
            const dot = document.createElementNS(svgNS, 'circle');
            dot.setAttribute('cx', startX);
            dot.setAttribute('cy', startY);
            dot.setAttribute('class', 'circuit-dot moving');
            dot.style.animationDelay = `${Math.random() * 2}s`;
            
            // Animar o ponto ao longo do caminho
            const pathLength = path.getTotalLength();
            dot.style.offsetPath = `path('${pathData}')`;
            dot.style.offsetDistance = '0%';
            
            g.appendChild(path);
            g.appendChild(dot);
            svg.appendChild(g);
            
            // Remover após animação
            setTimeout(() => {
                if (g.parentNode) {
                    g.parentNode.removeChild(g);
                }
            }, 4000);
        }

        // Criar circuitos animados continuamente
        setInterval(createAnimatedCircuit, 300);

        // Criar alguns circuitos iniciais
        for (let i = 0; i < 15; i++) {
            setTimeout(createAnimatedCircuit, i * 150);
        }
    </script>
</body>
</html>